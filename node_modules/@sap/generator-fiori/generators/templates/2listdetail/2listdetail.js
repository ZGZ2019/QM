define([ "../shared"], function (shared) {
	return function() {
		return {

			/**
			 *    SAPUI5 Web IDE templates 1.50
			 */

			/**
			 * This hook is used to modify the model (which defines the template wizard UI) before it is displayed.
			 */
			onBeforeTemplateCustomizationLoaded: function (wizModel, tmplModel) {
				shared.modifyModelMobile(wizModel, tmplModel, "2masterdetail");
				shared.modifyModelExternally(tmplModel, "2masterdetail");
				return [wizModel, tmplModel];
			},

			/**
			 * Applies template logic before generating the template resources in the provided zip file.
			 *
			 * This method is executed before passing the model into the template resources,
			 * and is therefore ideal for model manipulations.
			 *
			 * Note that this method is not called for templates that do not include resources.
			 *
			 * @param templateZip The zip bundle containing the template resources that are about to be generated,
			 * as provided by the template.
			 *
			 * @param model The template model as passed from the generation wizard based on the user selections.
			 */
			onBeforeTemplateGenerate: function (templateZip, model) {
				model["2masterdetail"].parameters.ApplicationNamespace.value = model["2masterdetail"].parameters.ApplicationNamespace.value + "." + model.projectName;
				model.isModule = model.selectedTemplate._mConfig.templateType === "module";
				shared.registerHandlebarHelpers();
				shared.modifyModelDatasource(model);
				shared.modifyModelNavigationHack(model, "2masterdetail");
				shared.modifyModelAddEnvironment(model, "2masterdetail");
				shared.modifyNeoWelcomeFile(model, "2masterdetail");
				shared.handleServiceCatalog(model);
				return [templateZip, model];
			},

			/**
			 * Applies template logic after generating the template resources according to the template model
			 * and bundling the generated resources into the provided zip file.
			 *
			 * This method is executed after passing the model into the template resources
			 * but before extracting the generated project zip file to the SAP RDE workspace.
			 * Therefore, this method is ideal for manipulating the generated project files
			 * (for example, renaming files according to the template model).
			 *
			 * @param projectZip The zip bundle containing all the generated project resources,
			 * after applying the model parameters on the template resources.
			 *
			 * @param model The template model as passed from the generation wizard based on the user selections.
			 */
			onAfterGenerate: function (projectZip, model) {
				if (model["2masterdetail"].parameters.Object_Identifier.value.type === "Edm.Int32") {
					shared.modifyController(projectZip, model, "webapp/controller/Master.controller.js");
				}
				var sObjectTitle = model["2masterdetail"].parameters.Object_Identifier.value.name;
				if (sObjectTitle.indexOf("/") > 0) {
					shared.modifyController(projectZip, model, "webapp/controller/Detail.controller.js", sObjectTitle);
				}

				shared.addNeoDestinations(model);
				shared.modifyZipMetadataWorkaround(projectZip, model);
				shared.modifyZipRemoveMockdata(projectZip);
				shared.modifyZipFLP(projectZip, model, "2masterdetail");
				shared.modifyZipExternally(projectZip);
				shared.modifyProjectExternalBuild(this.context, model);
				this._setDatabindingForLayoutEditor(this.context, model);
				this._modifyZipGrouper(projectZip, model, "2masterdetail");

				// In case of module template we should remove the pom.xml
				if (model.isModule) {
					projectZip.remove("pom.xml");
				}

				return [projectZip, model];
			},

			/**
			 * remove grouper functionality if there is no object number
			 */
			_modifyZipGrouper: function (oProjectZip, oModel, sTemplateName) {
				if (!oModel[sTemplateName].parameters.Object_Number.value) {
					oProjectZip.remove("webapp/model/grouper.js");
					oProjectZip.remove("webapp/test/unit/model/grouper.js");
					oProjectZip.remove("webapp/model/GroupSortState.js");
					oProjectZip.remove("webapp/test/unit/model/GroupSortState.js");
				}
			},

			/**
			 * The current validation infrastructure uses project type to check that the template can be selected in the wizard
			 * within the context of the user selections.
			 * It is used for preventing the user from selecting the template when it is not appropriate according to previous
			 * selections in the generation wizard (or in the work space).
			 * This new method receives the model as passed from the wizard and must return a boolean value or throw an
			 * exception with the appropriate error message to the user.
			 *
			 * By default this method returns true.Use this method to add more validations, if needed.
			 *
			 * @param model The template model as passed from the generation wizard based on the user selections.
			 */
			customValidation: function (model) {
				return true;
			},

			/**
			 * Configures the wizard steps that appear after the template is selected in the wizard.
			 *
			 * The method arguments are the wizard step objects that appear after selecting the template.
			 * These steps are defined in the 'wizardSteps' property of the template configuration entry
			 * (located in the plugin.json file of the plugin containing the template).
			 *
			 * The method is used for setting step parameters and event handlers
			 * that define the appropriate relations between the steps.
			 *
			 * For example, to define how 'step2' handles changes that occur in 'step1':
			 *
			 * var oStep1Content = oStep1.getStepContent();
			 * var oStep2Content = oStep2.getStepContent();
			 *
			 // To handle validation status changes in oStep1Content:
			 * oStep1Content.attachValidation(oStep2Content.someHandlerMethod, oStep2Content);
			 *
			 // To handle value changes in oStep1Content:
			 * oStep1Content.attachValueChange(oStep2Content.anotherHandlerMethod, oStep2Content);
			 *
			 */
			configWizardSteps: function () {
			},

			_setDatabindingForLayoutEditor: function (oContext, oModel) {
				var templateName = "2masterdetail";

				var oBindingSettings = {
					"/webapp/view/App.view.xml": {"entitySet": "UNBINDKEY"},
					"/webapp/view/NotFound.view.xml": {"entitySet": "UNBINDKEY"},
					"/webapp/view/DetailObjectNotFound.view.xml": {"entitySet": "UNBINDKEY"},
					"/webapp/view/DetailNoObjectsAvailable.view.xml": {"entitySet": "UNBINDKEY"},
					"/webapp/view/Master.view.xml": {"entitySet": oModel[templateName].parameters.ObjectCollection.value.name},
					"/webapp/view/Detail.view.xml": {"entitySet": oModel[templateName].parameters.ObjectCollection.value.name}
				};

				return this.context.service.repositorybrowser.getSelection().then(function (oSelection) {
					var _docPath;
					var _mtaTypes = _.filter(oModel.selectedTemplate.getSupportedProjectTypes(), function (oTemplType) {
						if (oTemplType === "mta") {
							return true;
						}
					});

					if (oModel.selectedTemplate.getType() === "module" && _mtaTypes.length) {
						// model typed template
						_docPath = oSelection[0].document.getEntity().getFullPath() + "/" + oModel.projectName;
					} else {
						// project typed template
						_docPath = "/" + oModel.projectName;
					}

					return oContext.service.filesystem.documentProvider.getDocument(_docPath).then(function (oProjectDocument) {
						oContext.service.setting.project.setProjectSettings("dataBinding", oBindingSettings, oProjectDocument).done();
					});
				});
			}

		};
	}
});